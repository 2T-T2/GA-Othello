// Generated by CoffeeScript 2.5.1
(function() {
  var BLANK, GeneticAlgorithm, KURO, Main, MatchNum, MaxGeneration, MaxPopulation, Othello, SIRO, boardlog, log, main, randomArr, randomChoiceArr, randomInt, range, sleep;

  range = function(number, number2) {
    if (number2 === void 0) {
      return (function() {
        var results = [];
        for (var k = 0; 0 <= number ? k < number : k > number; 0 <= number ? k++ : k--){ results.push(k); }
        return results;
      }).apply(this);
    } else {
      return (function() {
        var results = [];
        for (var k = number; number <= number2 ? k < number2 : k > number2; number <= number2 ? k++ : k--){ results.push(k); }
        return results;
      }).apply(this);
    }
  };

  log = function(val) {
    return console.log(val);
  };

  sleep = function(ms) {
    var results, start;
    start = new Date().getTime();
    results = [];
    while (new Date().getTime() - start < ms) {
      continue;
    }
    return results;
  };

  boardlog = function(val) {
    var i, j, k, l, len, len1, ref, ref1, results, str;
    str = "";
    ref = range(val.length);
    results = [];
    for (k = 0, len = ref.length; k < len; k++) {
      i = ref[k];
      ref1 = range(val[0].length);
      for (l = 0, len1 = ref1.length; l < len1; l++) {
        j = ref1[l];
        if (val[i][j] === -1) {
          str = str + val[i][j] + " ";
        } else {
          str = str + " " + val[i][j] + " ";
        }
      }
      results.push(str = str + "\n");
    }
    return results;
  };

  randomInt = function(num, num2) {
    if (num2 === void 0) {
      return Math.floor(Math.random() * Math.floor(num));
    } else {
      return Math.floor((num2 - num + 1) * Math.random() + num);
    }
  };

  randomArr = function(num) {
    var arr, i, k, len, ref;
    arr = [];
    ref = range(num);
    for (k = 0, len = ref.length; k < len; k++) {
      i = ref[k];
      arr.push(Math.random());
    }
    return arr;
  };

  randomChoiceArr = function(arr) {
    var index;
    index = randomInt(arr.length);
    return arr[index];
  };

  KURO = -1;

  SIRO = 1;

  BLANK = 0;

  MaxGeneration = 30;

  MaxPopulation = 30;

  MatchNum = 30;

  Main = class Main {
    constructor(args) {
      var Drow, KURO_Cnt, KURO_PlacebleList, SIRO_Cnt, SIRO_PlacebleList, Win_Cnt, gameEnd, generationCnt, geneticAlgorithm, i, k, l, len, len1, len2, len3, m, match, n, number, othello, ref, ref1, ref2, ref3;
      geneticAlgorithm = new GeneticAlgorithm(KURO);
      gameEnd = false;
      KURO_Cnt = 0;
      SIRO_Cnt = 0;
      Drow = 0;
      Win_Cnt = 0;
      ref = range(MaxGeneration);
      //世代数ループ
      for (k = 0, len = ref.length; k < len; k++) {
        generationCnt = ref[k];
        ref1 = range(MaxPopulation);
        //１世代の人数ループ
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          number = ref1[l];
          ref2 = range(MatchNum);
          for (m = 0, len2 = ref2.length; m < len2; m++) {
            match = ref2[m];
            othello = new Othello();
            gameEnd = false;
            ref3 = range(40);
            //１試合ループ
            for (n = 0, len3 = ref3.length; n < len3; n++) {
              i = ref3[n];
              KURO_PlacebleList = othello.getPlacebleList(KURO);
              if (KURO_PlacebleList.length !== 0) {
                othello.reverse(geneticAlgorithm.Act(KURO_PlacebleList, number), KURO);
                gameEnd = false;
              } else {
                if (!gameEnd) {
                  gameEnd = true;
                } else {
                  break;
                }
              }
              SIRO_PlacebleList = othello.getPlacebleList(SIRO);
              if (SIRO_PlacebleList.length !== 0) {
                othello.reverse(this.randomChoice(SIRO_PlacebleList), SIRO);
                gameEnd = false;
              } else {
                if (!gameEnd) {
                  gameEnd = true;
                } else {
                  break;
                }
              }
            }
            if (othello.judge() === geneticAlgorithm.me) {
              Win_Cnt++;
            }
          }
          geneticAlgorithm.rating(Win_Cnt, number);
          Win_Cnt = 0;
          if (othello.judge() === KURO) {
            KURO_Cnt++;
          } else if (othello.judge() === SIRO) {
            SIRO_Cnt++;
          } else {
            Drow++;
          }
        }
        log({
          "SIRO": SIRO_Cnt,
          "KURO": KURO_Cnt,
          "Drow": Drow
        });
        SIRO_Cnt = 0;
        KURO_Cnt = 0;
        Drow = 0;
        geneticAlgorithm.makeNextGeneration(generationCnt);
      }
      log(geneticAlgorithm.Strongest());
    }

    randomChoice(placeblelist) {
      var index;
      index = randomInt(placeblelist.length);
      return placeblelist[index];
    }

  };

  Othello = (function() {
    class Othello {
      constructor() {
        this.board = [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, -1, 1, 0, 0, 0], [0, 0, 0, 1, -1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]];
        this.size = {
          "height": 8,
          "width": 8
        };
      }

      getPlacebleList(player) {
        var cnt, dx, dy, k, l, len, len1, len2, len3, list, m, n, ref, ref1, ref2, ref3, x, y;
        list = [];
        ref = range(this.size["height"]);
        for (k = 0, len = ref.length; k < len; k++) {
          x = ref[k];
          ref1 = range(this.size["width"]);
          for (l = 0, len1 = ref1.length; l < len1; l++) {
            y = ref1[l];
            ref2 = range(-1, 2);
            for (m = 0, len2 = ref2.length; m < len2; m++) {
              dx = ref2[m];
              ref3 = range(-1, 2);
              for (n = 0, len3 = ref3.length; n < len3; n++) {
                dy = ref3[n];
                if (dx === 0 && dy === 0) {
                  continue;
                }
                if (this.board[y][x] === BLANK) {
                  cnt = this.cntStones(x, y, dx, dy, player);
                  if (cnt !== 0) {
                    list.push({
                      "x": x,
                      "y": y
                    });
                  }
                }
              }
            }
          }
        }
        return list;
      }

      cntStones(x, y, dx, dy, player) {
        var cnt;
        cnt = 1;
        if (y + cnt * dy < 0 || x + cnt * dx < 0 || y + cnt * dy >= this.size["height"] || x + cnt * dx >= this.size["width"]) {
          return 0;
        }
        while (this.board[y + cnt * dy][x + cnt * dx] === -player) {
          if (y + (cnt + 1) * dy < 0 || x + (cnt + 1) * dx < 0 || y + (cnt + 1) * dy >= this.size["height"] || x + (cnt + 1) * dx >= this.size["width"]) {
            return 0;
          }
          cnt++;
        }
        if (this.board[y + cnt * dy][x + cnt * dx] === player) {
          return cnt - 1;
        }
        return 0;
      }

      reverse(putPoint, player) {
        var cnt, dx, dy, k, len, p, ref, results, x, y;
        x = putPoint["x"];
        y = putPoint["y"];
        cnt = 1;
        ref = range(-1, 2);
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          dx = ref[k];
          results.push((function() {
            var l, len1, ref1, results1;
            ref1 = range(-1, 2);
            results1 = [];
            for (l = 0, len1 = ref1.length; l < len1; l++) {
              dy = ref1[l];
              if (dx === 0 && dy === 0) {
                continue;
              }
              cnt = this.cntStones(x, y, dx, dy, player);
              results1.push((function() {
                var len2, m, ref2, results2;
                ref2 = range(cnt + 1);
                results2 = [];
                for (m = 0, len2 = ref2.length; m < len2; m++) {
                  p = ref2[m];
                  results2.push(this.board[y + p * dy][x + p * dx] = player);
                }
                return results2;
              }).call(this));
            }
            return results1;
          }).call(this));
        }
        return results;
      }

      judge() {
        var BLANK_Cnt, KURO_Cnt, SIRO_Cnt, k, l, len, len1, point, ref, row;
        KURO_Cnt = 0;
        SIRO_Cnt = 0;
        BLANK_Cnt = 0;
        ref = this.board;
        for (k = 0, len = ref.length; k < len; k++) {
          row = ref[k];
          for (l = 0, len1 = row.length; l < len1; l++) {
            point = row[l];
            if (point === KURO) {
              KURO_Cnt++;
            } else if (point === SIRO) {
              SIRO_Cnt++;
            } else {
              BLANK_Cnt++;
            }
          }
        }
        if (KURO_Cnt > SIRO_Cnt) {
          return KURO;
        } else if (KURO_Cnt < SIRO_Cnt) {
          return SIRO;
        } else {
          return BLANK;
        }
      }

    };

    Othello.prototype.board = [];

    Othello.prototype.size = {};

    return Othello;

  }).call(this);

  GeneticAlgorithm = (function() {
    class GeneticAlgorithm {
      constructor(myColor) {
        var i, k, len, ref;
        this.me = myColor;
        ref = range(MaxPopulation);
        for (k = 0, len = ref.length; k < len; k++) {
          i = ref[k];
          this.CurrentGeneration.push(randomArr(64));
        }
      }

      Act(placeblelist, number) {
        var index, indexList, k, len, p, val, valList;
        indexList = [];
        valList = [];
        for (k = 0, len = placeblelist.length; k < len; k++) {
          p = placeblelist[k];
          indexList.push(p["x"] * 8 + p["y"]);
          valList.push(this.CurrentGeneration[number][p["x"] * 8 + p["y"]]);
        }
        val = Math.max(...valList);
        index = this.CurrentGeneration[number].indexOf(val);
        if (index === -1) {
          log(this.CurrentGeneration[number][0].length);
        }
        return {
          "x": Math.floor(index / 8),
          "y": index % 8
        };
      }

      rating(winnum, number) {
        this.RewardList.push({
          "WinCnt": winnum,
          "gane": this.CurrentGeneration[number]
        });
        if (this.StrongestWinCnt <= winnum) {
          this.StrongestWinCnt = winnum;
          return this.StrongestGane = this.CurrentGeneration[number];
        }
      }

      makeNextGeneration(geneCnt) {
        var i, k, len, parent, ref;
        ref = range(MaxPopulation);
        for (k = 0, len = ref.length; k < len; k++) {
          i = ref[k];
          parent = this.select();
          if (parent.length === 2) {
            this.NextGeneration.push(this.cross(parent));
          } else {
            if (Math.random() > this.MutaionPer) {
              this.NextGeneration.push(this.copy(parent));
            } else {
              this.NextGeneration.push(this.mutaion(parent));
            }
          }
        }
        this.CurrentGeneration = this.NextGeneration;
        this.NextGeneration = [];
        return this.RewardList = [];
      }

      mutaion(parent) {
        var point1, point2, point3, val;
        point1 = randomInt(parent[0].length);
        point2 = randomInt(parent[0].length);
        point3 = randomInt(parent[0].length);
        val = parent[0];
        val[point1] = Math.random();
        val[point2] = Math.random();
        val[point3] = Math.random();
        return val;
      }

      copy(parent) {
        return parent[0];
      }

      cross(parent) {
        var Child, arr1, arr2, arr3, i, k, len, point1, point2, ref, tmp;
        Child = [];
        if (this.UniformCrossPer < Math.random()) {
          point1 = randomInt(parent[0].length);
          point2 = randomInt(parent[0].length);
          if (point1 > point2) {
            tmp = point1;
            point1 = point2;
            point2 = tmp;
          }
          arr1 = parent[0].slice(0, point1);
          arr2 = parent[1].slice(point1, point2);
          arr3 = parent[0].slice(point2);
          Child = Child.concat(arr1);
          Child = Child.concat(arr2);
          Child = Child.concat(arr3);
        } else {
          ref = range(parent[0].length);
          for (k = 0, len = ref.length; k < len; k++) {
            i = ref[k];
            if (0.5 > Math.random()) {
              Child.push(parent[0][i]);
            } else {
              Child.push(parent[1][i]);
            }
          }
        }
        return Child;
      }

      select() {
        var k, len, notwinnnerData, parent, ref, reward, winnerData;
        parent = [];
        winnerData = [];
        notwinnnerData = [];
        ref = this.RewardList;
        for (k = 0, len = ref.length; k < len; k++) {
          reward = ref[k];
          if (reward["WinCnt"] >= MatchNum * 3 / 4) {
            winnerData.push(reward["gane"]);
          } else {
            notwinnnerData.push(reward["gane"]);
          }
        }
        if (Math.random() < this.WinnerSelectionPer) {
          parent.push(randomChoiceArr(winnerData));
        } else {
          parent.push(randomChoiceArr(notwinnnerData));
        }
        if (Math.random() < this.CrossPer) {
          if (Math.random() < this.WinnerSelectionPer) {
            parent.push(randomChoiceArr(winnerData));
          } else {
            parent.push(randomChoiceArr(notwinnnerData));
          }
        }
        return parent;
      }

      Strongest() {
        return {
          "win": this.StrongestWinCnt,
          "gane": this.StrongestGane
        };
      }

    };

    GeneticAlgorithm.prototype.me = 0;

    GeneticAlgorithm.prototype.CurrentGeneration = [];

    GeneticAlgorithm.prototype.NextGeneration = [];

    GeneticAlgorithm.prototype.MutaionPer = 0.01;

    GeneticAlgorithm.prototype.CrossPer = 0.9;

    GeneticAlgorithm.prototype.UniformCrossPer = 0.15;

    GeneticAlgorithm.prototype.WinnerSelectionPer = 0.8;

    GeneticAlgorithm.prototype.RewardList = [];

    GeneticAlgorithm.prototype.StrongestWinCnt = 0;

    GeneticAlgorithm.prototype.StrongestGane = [];

    return GeneticAlgorithm;

  }).call(this);

  main = new Main();

}).call(this);
